/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>
#include <kern/macro.h>

#include <kern/picirq.h>


###################################################################
# exceptions/interrupts
###################################################################

/* TRAPHANDLER defines a globally-visible function for handling a trap.
 * It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 *
 * You shouldn't call a TRAPHANDLER function from C, but you may
 * need to _declare_ one in C (for instance, to get a function pointer
 * during IDT setup).  You can declare the function with
 *   void NAME();
 * where NAME is the argument passed to TRAPHANDLER.
 */
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushq $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushq $0;							\
	pushq $(num);							\
	jmp _alltraps

.text

TRAPHANDLER_NOEC(CSE_DIVIDE,0)      /* divide error*/ 
TRAPHANDLER_NOEC(CSE_DEBUG,1)      /* debug exception*/
TRAPHANDLER_NOEC(CSE_NMI,2)     /* non-maskable interrupt*/
TRAPHANDLER_NOEC(CSE_BRKPT,3)     /* breakpoint*/
TRAPHANDLER_NOEC(CSE_OFLOW,4)     /* overflow*/
TRAPHANDLER_NOEC(CSE_BOUND,5)     /* bounds check*/
TRAPHANDLER_NOEC(CSE_ILLOP,6)     /* illegal opcode*/
TRAPHANDLER_NOEC(CSE_DEVICE,7)     /* device not available*/
TRAPHANDLER(CSE_DBLFLT,8)      /* double fault*/
/* #define T_COPROC  9    // reserved (not generated by recent processors)*/
TRAPHANDLER(CSE_TSS,10)     /* invalid task switch segment*/
TRAPHANDLER(CSE_SEGNP,11)      /* segment not present*/
TRAPHANDLER(CSE_STACK,12)      /* stack exception*/
TRAPHANDLER(CSE_GPFLT,13)      /* general protection fault*/
TRAPHANDLER(CSE_PGFLT,14)      /* page fault*/
/* #define T_RES    15    // reserved*/
TRAPHANDLER_NOEC(CSE_FPERR,16)      /* floating point error*/
TRAPHANDLER_NOEC(CSE_ALIGN,17)      /* aligment check*/
TRAPHANDLER_NOEC(CSE_MCHK,18)      /* machine check*/
TRAPHANDLER_NOEC(CSE_SIMDERR,19)      /* SIMD floating point error*/



TRAPHANDLER_NOEC(CSE_SYSCALL,48) /* System call */
/*IRQ (HW INTERRUPTS)*/
TRAPHANDLER_NOEC(CSE_IRQ0, 32)
TRAPHANDLER_NOEC(CSE_IRQ1, 33)
TRAPHANDLER_NOEC(CSE_IRQ2, 34)
TRAPHANDLER_NOEC(CSE_IRQ3, 35)
TRAPHANDLER_NOEC(CSE_IRQ4, 36)
TRAPHANDLER_NOEC(CSE_IRQ5, 37)
TRAPHANDLER_NOEC(CSE_IRQ6, 38)
TRAPHANDLER_NOEC(CSE_IRQ7, 39)
TRAPHANDLER_NOEC(CSE_IRQ8, 40)
TRAPHANDLER_NOEC(CSE_IRQ9, 41)
TRAPHANDLER_NOEC(CSE_IRQ10, 42)
TRAPHANDLER_NOEC(CSE_IRQ11, 43)
TRAPHANDLER_NOEC(CSE_IRQ12, 44)
TRAPHANDLER_NOEC(CSE_IRQ13, 45)
TRAPHANDLER_NOEC(CSE_IRQ14, 46)
TRAPHANDLER_NOEC(CSE_IRQ15, 47)

/*
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */
.global _alltraps
_alltraps:
	subq $8,%rsp 
	movw %ds,(%rsp)
	subq $8,%rsp
	movw %es,(%rsp)
	PUSHA
	movq $GD_KD,%rax
	movw %rax,%ds
	movw %rax,%es
	movq %rsp,%rdi
	/*movq $0, %rbp*/
	call trap
	POPA_
	add $8, %rsp
	movw (%rsp),%es
	add $8, %rsp
	movw (%rsp),%ds
	iret

/*
 * Lab 3: Your code here for _alltraps
 *
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */

